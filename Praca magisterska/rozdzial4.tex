\chapter{Wykorzystane biblioteki i narzędzia}

\section{ECLiPSe}

% SW: Powiedziałbym, że ECLiPSe to środowisko do wykonwania programów CLP (trudno powiedzieć, że służy do tworzenia aplikacji.
ECLiPSe\cite{EclipseSite} jest systemem typu open-source do tworzenia aplikacji wykorzystujących paradygmat programowania logicznego z ograniczeniami. System ten użyty został do testowania przykładowych procedur medycznych. 
% SW: Tutaj warto wyjaśnić, dlaczego nie zostało wykorzystane w systemie realizowanym w ramach pracy (np. z uwagi na ograniczaną możliwość intergracji z programami w języku Java).

Nie współpracuje natomiast z wykonanym w ramach pracy magisterskiej systemem, jest to odrębny program. 
% SW: Rozumiem, że tutaj pisze Pan o częściach głównego okna systemu ECLiPse -- sądzę, że należy to jasno powiedieć, a także zamieścić przykładowy ekran.

ECLiPSe składa się z trzech części. Pierwsza część służy do wprowadzania komend. Zamiast wprowadzania komend można wczytać gotowy program z pliku za pomocą polecenia Compile znajdującym się w menu File. Druga część programu wyświetla wyniki, trzecia natomiast pokazuje ewentualne błędy oraz inne komunikaty. 
% SW: Taki fragmentaryczny opis składni jest mało przdatny. Napisałbym raczej, że przykładowy program przedstawiono w poprzedniej sekcji. Poza tym w poprzedniej sekcji umieściłbym tłumaczenia dotyczące interpretacji symboli "\#=" i "\#", ponieważ pojawiają się one w przykładowym programie.

Komendy dla tego systemu składają się ze zdań zakończonych kropką, poszczególne fragmenty zdań są oddzielone od siebie przecinkami. Znak równości to między zmiennymi lub wartościami liczbowymi to „\#=”, znak nierówności to „\#\textbackslash=”. Można stosować także operatory and i or i przypisywać ich wartość do zmiennych za pomocą znaku równości. 

\section{Choco 3}

% SW: Tutaj napisałbym, że Choco jest biblioteką w języku Java, która pozwala na rozwiązywanie problemów CLP. Oferuje zatem funkcjonalność zbliżoną do ECLiPSe'a, chociaż nie ma interfejsu użytkownika. Dostępna jest na licencji open source.

Choco\cite{Choco3} jest darmowym oprogramowaniem typu open-source wykorzystującym paradygmat programowania z ograniczeniami. Jest to biblioteka oparta o język Java w wersji 8. Główną klasą biblioteki jest klasa \texttt{Solver}. 
% SW: Tutaj duzym ułatwieniem byłoby wstawienie fragmetu kodu definiującego prosty problem i odwołanie się do poszczególnych linii w tłumaczeniu. Poza tym odpowiednie formatowanie tekstu (np. zastosowanie \texttt dla kodu) poprawi jego czytelność (zmieniłem formatowanie w tej sekcji). Poza tym zamiast pisać "metoda xxx w klasie Yyy" lepiej chyba zastosować konwencję "metoda Yyy.xxx".
Do obiektu typu \texttt{Solver} można dołączyć zmienną (klasa \texttt{IntVar}) podając obiekt \texttt{Solver-a} w ostatnim argumencie metody \texttt{bounded} klasy \texttt{VariableFactory}. Pozostałe argumenty tej metody to nazwa zmiennej oraz dolne i górne ograniczenie zmiennej. W pracy magisterskiej wykorzystywane są w większości zmienne, dla których dolne ograniczenie jest równe 0, a górne ograniczenie jest równe 1, czyli są to zmienne przyjmujące wartości prawda/fałsz. Za pomocą funkcji \texttt{post} klasy \texttt{Solver} można dodawać nowe ograniczenia. Ograniczenia tworzy się m. in. za pomocą klasy \texttt{IntConstraintFactory}. Jedną z podstawowych metod tworzących ograniczenia jest funkcja metoda. Przykładowo, można za jej pomocą określić, że suma dwóch zmiennych X i Y ma być mniejsza od 5. Po określeniu ograniczeń można uruchomić \texttt{Solver} i wygenerować rozwiązanie za pomocą metody \texttt{findSolution}. Kolejne rozwiązania można uzyskać za pomocą metody \texttt{nextSolution}. Odczytanie wartości zmiennej określonego rozwiązania polega na wywołaniu metody \texttt{getValue} klasy \texttt{IntVar}. 

% SW: Najpierw powinien Pan opisać Graphviz-a (wraz z formatem .dot), a dopiero później bibliotekę służącą do odczytu plików .dot i tworzenia ich reprezentacji obiektowej w Javie.
\section{JPGD - A Java parser for Graphviz documents}

% SW: JPGD jest biblioteką ogólnego przeznaczenia i służy do analizy dowolnych grafów, a nie tylko tych opisujących wytyczne.

% SW: Poniższy opis wydaje się być zbyt szczegółowy, biorąc pod uwagę pomocniczy charakter biblioteki. Poza tym zastosowanie mają wszystkie te uwagi, które sformułowałem w przypadku opisu Choco 3 (dodanie przykładowego kodu źródłowego, zmiana formatowania i zapisu klas/metod).

% SW: Proszę podzielić ten tekst na akaipty -- obecnie mamy jeden wielki akapit obejmujący całą sekcję, a to utrudnia czytanie.

Biblioteka\cite{JPGD} ta służy do konwersji pliku o rozszerzeniu dot opisującego graf procedury medycznej na obiekt klasy Graph posiadający listę obiektów klasy Node oraz Edge. Do konwersji wykorzystywany jest obiekt klasy Parser. Klasa Parser posiada funkcję parse, której konstruktor jako parametr przyjmuje obiekt klasy FileReader odwołujący się do określonego pliku o rozszerzeniu dot. W następnym kroku można odczytać obiekt klasy Graph z listy tych obiektów uzyskanej za pomocą funkcji getGraphs (jest to funkcja klasy Parser). Węzły grafu można odczytać za pomocą funkcji getNodes wywołanej dla obiektu klasy Graph. Krawędzie grafu można natomiast uzyskać za pomocą funkcji getEdges, która również jest funkcją klasy Graph. Węzły oraz krawędzie posiadają atrybuty. Do atrybutów węzłów należy zaliczyć etykietę, kształt, kolor wypełnienia, kolor konturu i grubość linii konturu. Krawędzie posiadają przede wszystkim jeden istotny atrybut – etykietę. Odczytać wartości atrybutów można za pomocą funkcji getAttribute, której argumentem jest nazwa atrybutu. Ustawić wartości atrybutu można natomiast za pomocą metody setAttribute, której pierwszym argumentem jest nazwa atrybutu, a drugim jego wartość. Każdy węzeł grafu będącym w formacie dot posiada także swój unikalny identyfikator. Identyfikatory przechowywane są w obiektach klasy Id. Obiekt takiej klasy dla określonego węzła można uzyskać wywołując funkcję getId() na rzecz obiektu klasy Node. Ponowne wywołanie funkcji getId, w tym przypadku dla obiektu klasy Id uzyskuje rzeczywisty identyfikator węzła typu String. Jeśli chodzi o krawędzie, to posiadają one możliwość odczytania węzła źródłowego oraz docelowego danej krawędzi. Jest to możliwe dzięki wywołaniu funkcji getSource (dla uzyskania węzła źródłowego) oraz getTarget (dla uzyskania węzła docelowego). Dzięki tym funkcjom uzyskujemy obiekt klasy PortNode, z którego następnie możemy uzyskać obiekt klasy Node za pomocą funkcji getNode. Ważną funkcją jest też funkcja toString wywoływana na rzecz obiektu klasy Graph. Pozwala ona na uzyskanie grafu w formacie dot zawierającym zmiany wprowadzone za pomocą metody setAttribute dla obiektów klasy Node lub Edge. 
% SW: Rozumiem, że musiał Pan samodzielnie poprawiać te błędy podczas realizacji pracy. Ten fragment warto przenieśc do podsumowania, gdzie opisuje Pan napotkane problemy.

Aby wygenerowany graf był poprawny, konieczna była modyfikacja metody toString dla klas Graph, Node oraz Edge, gdyż biblioteka zawiera w przypadku tych metod drobne błędy. Po uzyskaniu grafu w formacie dot można go następnie zapisać do pliku, aby móc z niego później skorzystać.

\section{Graphviz}

% SW: Graphviz jest pakietem do wizualizacji różnego typu grafów i zawiera kilka dedykowanych programów. My wykorzystujemy tylko jeden z nich - dot -- do tworzenia hierarchicznych grafów skierowanych.

% SW: Podobnie jak poprzednio, ten opis można skrócić i zastąpić częściowo przykładami prostych plików .dot wraz z wygenerowanymi obrazami. Warto też poprawić formatowanie. Wreszcie można zrezygnować z opisu parametrów wywołania programu -- ta informacja jest zbyt szczegółowa. Wreszcie mówiłbym raczej o formacie, a a nie rozszerzeniu .dot (to rozszerzenie wykorzystywane jest także przez inne programy, np. Word-a).

% SW: Podobnie jak poprzednmio, proszę podzielić ten tekst na krótsze akapity.

Graphviz\cite{Graphviz} jest oprogramowaniem służącym do wizualizacji grafów. Pozwala na konwersję pliku tekstowego o rozszerzeniu .dot do obrazu przedstawiającego graf. 
% SW: dot nie tylko automatycznie rozmieszcza węzły, ale również automatycznie prowadzi krawędzie, aby ograniczyć liczbę ich przecięć.
Program automatycznie porządkuje węzły na obrazie, nie jest konieczne podawanie pozycji węzłów, czyli ich współrzędnych. Program z pakiety Graphviz o nazwie gvedit.exe jest programem okienkowym, który pozwala na wybranie w oknie dialogowym pliku o rozszerzeniu dot. Po wybraniu tego pliku albo wypisywana jest lista błędów, które należy poprawić, albo wyświetlany jest obraz przedstawiający graf. Podobną funkcjonalność ma program dot.exe, z tą różnicą, że jest to program konsolowy. Program dot.exe posiada 3 argumenty. Pierwszym argumentem jest ścieżka do pliku z rozszerzeniem dot, drugim jest format generowanego obrazu (przykładowo dla uzyskania formatu png obrazka podajemy drugą wartość argumentu równą –Tpng). Między drugim a trzecim argumentem należy podać przełącznik „-o”. Trzecim argumentem jest ścieżka wynikowego obrazu. Jeśli chodzi o plik z rozszerzeniem dot, jest to plik, który posiada swoją własną składnię. Na początku pliku umieszczone jest słowo „digraph”, po którym umieszcza się nazwę grafu. Wszystkie pozostałe właściwości grafu są umieszczone w bloku otoczonym nawiasami klamrowymi. W bloku tym można podać globalne atrybuty dla węzłów oraz krawędzi. Atrybuty dla węzłów mogą być podane po słowie node w bloku otoczonym nawiasami kwadratowymi, atrybuty są oddzielone od siebie przecinkami. Do przykładowych globalnych atrybutów węzłów należą m. in. kształt (box – prostokąt, circle – koło, diamond – romb), kolor wypełnienia, kolor konturu, grubość linii konturu, rodzaj czcionki, wielkość czcionki. Jeśli chodzi o globalne atrybuty krawędzi, to można je podać w podobny sposób jak globalne atrybuty węzłów, z tą różnicą, że zamiast słowa „node” należy podać słowo „edge”. Do atrybutów globalnych krawędzi należą przede wszystkim wielkość i rodzaj czcionki (krawędzie mogą posiadać etykiety). W następnym kroku można podać węzły i krawędzie z ich atrybutami. Atrybut pojedynczego węzła lub krawędzi, jeśli już wystąpił w globalnych atrybutach węzłów lub krawędzi, zostaje nadpisany. Opis pojedynczego węzła polega na podaniu jego unikalnego identyfikatora, a następnie jego atrybutów w bloku otoczonym nawiasami kwadratowymi (atrybuty są podawane po przecinku).  Krawędzie natomiast tworzy się, podając na początku identyfikator węzła źródłowego krawędzi, następnie należy umieścić tzw. strzałkę („->”), a na końcu identyfikator węzła docelowego. Po podaniu tych elementów można podać atrybuty krawędzi, przede wszystkim etykietę. Co ciekawe, krawędź może być także nieskierowana, wtedy zamiast strzałki („->”) należy umieścić podwójną kreskę („--”). 
% SW: Poniższy fragment powinien przenieść Pan od opisu implementacji (nie dotyczy on bezpośrednio Graphviz-a).
W systemie, którego dotyczy praca magisterska, wykorzystano program dot.exe. Za pomocą funkcji getRuntime klasy Runtime uzyskujemy instancję obiektu klasy Runtime. Na rzecz tego obiektu można następnie wywołać funkcję exec, której argumentem jest tablica łańcuchów znaków zawierająca w pierwszym elemencie ścieżkę do programu (w tym przypadku dot.exe), a w pozostałych elementach argumenty programu. Następnie należy wywołać funkcję waitFor dla obiektu klasy Process, który uzyskujemy w wyniku wywołania funkcji exec.
